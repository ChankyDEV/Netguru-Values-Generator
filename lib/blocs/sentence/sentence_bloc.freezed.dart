// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'sentence_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SentenceEventTearOff {
  const _$SentenceEventTearOff();

  GetAllSentences getAllSentences() {
    return const GetAllSentences();
  }

  ShowNewRandomSentence showNewRandomSentence(Sentence sentence) {
    return ShowNewRandomSentence(
      sentence,
    );
  }

  AddToFavourite addToFavourite(Sentence sentence) {
    return AddToFavourite(
      sentence,
    );
  }

  NewSentenceValueChanged newSentenceValueChanged(String value) {
    return NewSentenceValueChanged(
      value,
    );
  }

  CreateNewSentence createNewSentence() {
    return const CreateNewSentence();
  }

  Reload reload() {
    return const Reload();
  }

  ClearNewSentenceValue clearNewSentenceValue() {
    return const ClearNewSentenceValue();
  }

  Reset reset() {
    return const Reset();
  }
}

/// @nodoc
const $SentenceEvent = _$SentenceEventTearOff();

/// @nodoc
mixin _$SentenceEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SentenceEventCopyWith<$Res> {
  factory $SentenceEventCopyWith(
          SentenceEvent value, $Res Function(SentenceEvent) then) =
      _$SentenceEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SentenceEventCopyWithImpl<$Res>
    implements $SentenceEventCopyWith<$Res> {
  _$SentenceEventCopyWithImpl(this._value, this._then);

  final SentenceEvent _value;
  // ignore: unused_field
  final $Res Function(SentenceEvent) _then;
}

/// @nodoc
abstract class $GetAllSentencesCopyWith<$Res> {
  factory $GetAllSentencesCopyWith(
          GetAllSentences value, $Res Function(GetAllSentences) then) =
      _$GetAllSentencesCopyWithImpl<$Res>;
}

/// @nodoc
class _$GetAllSentencesCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $GetAllSentencesCopyWith<$Res> {
  _$GetAllSentencesCopyWithImpl(
      GetAllSentences _value, $Res Function(GetAllSentences) _then)
      : super(_value, (v) => _then(v as GetAllSentences));

  @override
  GetAllSentences get _value => super._value as GetAllSentences;
}

/// @nodoc

class _$GetAllSentences implements GetAllSentences {
  const _$GetAllSentences();

  @override
  String toString() {
    return 'SentenceEvent.getAllSentences()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GetAllSentences);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return getAllSentences();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (getAllSentences != null) {
      return getAllSentences();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return getAllSentences(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (getAllSentences != null) {
      return getAllSentences(this);
    }
    return orElse();
  }
}

abstract class GetAllSentences implements SentenceEvent {
  const factory GetAllSentences() = _$GetAllSentences;
}

/// @nodoc
abstract class $ShowNewRandomSentenceCopyWith<$Res> {
  factory $ShowNewRandomSentenceCopyWith(ShowNewRandomSentence value,
          $Res Function(ShowNewRandomSentence) then) =
      _$ShowNewRandomSentenceCopyWithImpl<$Res>;
  $Res call({Sentence sentence});
}

/// @nodoc
class _$ShowNewRandomSentenceCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $ShowNewRandomSentenceCopyWith<$Res> {
  _$ShowNewRandomSentenceCopyWithImpl(
      ShowNewRandomSentence _value, $Res Function(ShowNewRandomSentence) _then)
      : super(_value, (v) => _then(v as ShowNewRandomSentence));

  @override
  ShowNewRandomSentence get _value => super._value as ShowNewRandomSentence;

  @override
  $Res call({
    Object? sentence = freezed,
  }) {
    return _then(ShowNewRandomSentence(
      sentence == freezed
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as Sentence,
    ));
  }
}

/// @nodoc

class _$ShowNewRandomSentence implements ShowNewRandomSentence {
  const _$ShowNewRandomSentence(this.sentence);

  @override
  final Sentence sentence;

  @override
  String toString() {
    return 'SentenceEvent.showNewRandomSentence(sentence: $sentence)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShowNewRandomSentence &&
            (identical(other.sentence, sentence) ||
                const DeepCollectionEquality()
                    .equals(other.sentence, sentence)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(sentence);

  @JsonKey(ignore: true)
  @override
  $ShowNewRandomSentenceCopyWith<ShowNewRandomSentence> get copyWith =>
      _$ShowNewRandomSentenceCopyWithImpl<ShowNewRandomSentence>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return showNewRandomSentence(sentence);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (showNewRandomSentence != null) {
      return showNewRandomSentence(sentence);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return showNewRandomSentence(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (showNewRandomSentence != null) {
      return showNewRandomSentence(this);
    }
    return orElse();
  }
}

abstract class ShowNewRandomSentence implements SentenceEvent {
  const factory ShowNewRandomSentence(Sentence sentence) =
      _$ShowNewRandomSentence;

  Sentence get sentence => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ShowNewRandomSentenceCopyWith<ShowNewRandomSentence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddToFavouriteCopyWith<$Res> {
  factory $AddToFavouriteCopyWith(
          AddToFavourite value, $Res Function(AddToFavourite) then) =
      _$AddToFavouriteCopyWithImpl<$Res>;
  $Res call({Sentence sentence});
}

/// @nodoc
class _$AddToFavouriteCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $AddToFavouriteCopyWith<$Res> {
  _$AddToFavouriteCopyWithImpl(
      AddToFavourite _value, $Res Function(AddToFavourite) _then)
      : super(_value, (v) => _then(v as AddToFavourite));

  @override
  AddToFavourite get _value => super._value as AddToFavourite;

  @override
  $Res call({
    Object? sentence = freezed,
  }) {
    return _then(AddToFavourite(
      sentence == freezed
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as Sentence,
    ));
  }
}

/// @nodoc

class _$AddToFavourite implements AddToFavourite {
  const _$AddToFavourite(this.sentence);

  @override
  final Sentence sentence;

  @override
  String toString() {
    return 'SentenceEvent.addToFavourite(sentence: $sentence)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddToFavourite &&
            (identical(other.sentence, sentence) ||
                const DeepCollectionEquality()
                    .equals(other.sentence, sentence)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(sentence);

  @JsonKey(ignore: true)
  @override
  $AddToFavouriteCopyWith<AddToFavourite> get copyWith =>
      _$AddToFavouriteCopyWithImpl<AddToFavourite>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return addToFavourite(sentence);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (addToFavourite != null) {
      return addToFavourite(sentence);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return addToFavourite(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (addToFavourite != null) {
      return addToFavourite(this);
    }
    return orElse();
  }
}

abstract class AddToFavourite implements SentenceEvent {
  const factory AddToFavourite(Sentence sentence) = _$AddToFavourite;

  Sentence get sentence => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AddToFavouriteCopyWith<AddToFavourite> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NewSentenceValueChangedCopyWith<$Res> {
  factory $NewSentenceValueChangedCopyWith(NewSentenceValueChanged value,
          $Res Function(NewSentenceValueChanged) then) =
      _$NewSentenceValueChangedCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class _$NewSentenceValueChangedCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $NewSentenceValueChangedCopyWith<$Res> {
  _$NewSentenceValueChangedCopyWithImpl(NewSentenceValueChanged _value,
      $Res Function(NewSentenceValueChanged) _then)
      : super(_value, (v) => _then(v as NewSentenceValueChanged));

  @override
  NewSentenceValueChanged get _value => super._value as NewSentenceValueChanged;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(NewSentenceValueChanged(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NewSentenceValueChanged implements NewSentenceValueChanged {
  const _$NewSentenceValueChanged(this.value);

  @override
  final String value;

  @override
  String toString() {
    return 'SentenceEvent.newSentenceValueChanged(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NewSentenceValueChanged &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  $NewSentenceValueChangedCopyWith<NewSentenceValueChanged> get copyWith =>
      _$NewSentenceValueChangedCopyWithImpl<NewSentenceValueChanged>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return newSentenceValueChanged(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (newSentenceValueChanged != null) {
      return newSentenceValueChanged(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return newSentenceValueChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (newSentenceValueChanged != null) {
      return newSentenceValueChanged(this);
    }
    return orElse();
  }
}

abstract class NewSentenceValueChanged implements SentenceEvent {
  const factory NewSentenceValueChanged(String value) =
      _$NewSentenceValueChanged;

  String get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NewSentenceValueChangedCopyWith<NewSentenceValueChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewSentenceCopyWith<$Res> {
  factory $CreateNewSentenceCopyWith(
          CreateNewSentence value, $Res Function(CreateNewSentence) then) =
      _$CreateNewSentenceCopyWithImpl<$Res>;
}

/// @nodoc
class _$CreateNewSentenceCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $CreateNewSentenceCopyWith<$Res> {
  _$CreateNewSentenceCopyWithImpl(
      CreateNewSentence _value, $Res Function(CreateNewSentence) _then)
      : super(_value, (v) => _then(v as CreateNewSentence));

  @override
  CreateNewSentence get _value => super._value as CreateNewSentence;
}

/// @nodoc

class _$CreateNewSentence implements CreateNewSentence {
  const _$CreateNewSentence();

  @override
  String toString() {
    return 'SentenceEvent.createNewSentence()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CreateNewSentence);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return createNewSentence();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (createNewSentence != null) {
      return createNewSentence();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return createNewSentence(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (createNewSentence != null) {
      return createNewSentence(this);
    }
    return orElse();
  }
}

abstract class CreateNewSentence implements SentenceEvent {
  const factory CreateNewSentence() = _$CreateNewSentence;
}

/// @nodoc
abstract class $ReloadCopyWith<$Res> {
  factory $ReloadCopyWith(Reload value, $Res Function(Reload) then) =
      _$ReloadCopyWithImpl<$Res>;
}

/// @nodoc
class _$ReloadCopyWithImpl<$Res> extends _$SentenceEventCopyWithImpl<$Res>
    implements $ReloadCopyWith<$Res> {
  _$ReloadCopyWithImpl(Reload _value, $Res Function(Reload) _then)
      : super(_value, (v) => _then(v as Reload));

  @override
  Reload get _value => super._value as Reload;
}

/// @nodoc

class _$Reload implements Reload {
  const _$Reload();

  @override
  String toString() {
    return 'SentenceEvent.reload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Reload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return reload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (reload != null) {
      return reload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return reload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (reload != null) {
      return reload(this);
    }
    return orElse();
  }
}

abstract class Reload implements SentenceEvent {
  const factory Reload() = _$Reload;
}

/// @nodoc
abstract class $ClearNewSentenceValueCopyWith<$Res> {
  factory $ClearNewSentenceValueCopyWith(ClearNewSentenceValue value,
          $Res Function(ClearNewSentenceValue) then) =
      _$ClearNewSentenceValueCopyWithImpl<$Res>;
}

/// @nodoc
class _$ClearNewSentenceValueCopyWithImpl<$Res>
    extends _$SentenceEventCopyWithImpl<$Res>
    implements $ClearNewSentenceValueCopyWith<$Res> {
  _$ClearNewSentenceValueCopyWithImpl(
      ClearNewSentenceValue _value, $Res Function(ClearNewSentenceValue) _then)
      : super(_value, (v) => _then(v as ClearNewSentenceValue));

  @override
  ClearNewSentenceValue get _value => super._value as ClearNewSentenceValue;
}

/// @nodoc

class _$ClearNewSentenceValue implements ClearNewSentenceValue {
  const _$ClearNewSentenceValue();

  @override
  String toString() {
    return 'SentenceEvent.clearNewSentenceValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ClearNewSentenceValue);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return clearNewSentenceValue();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (clearNewSentenceValue != null) {
      return clearNewSentenceValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return clearNewSentenceValue(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (clearNewSentenceValue != null) {
      return clearNewSentenceValue(this);
    }
    return orElse();
  }
}

abstract class ClearNewSentenceValue implements SentenceEvent {
  const factory ClearNewSentenceValue() = _$ClearNewSentenceValue;
}

/// @nodoc
abstract class $ResetCopyWith<$Res> {
  factory $ResetCopyWith(Reset value, $Res Function(Reset) then) =
      _$ResetCopyWithImpl<$Res>;
}

/// @nodoc
class _$ResetCopyWithImpl<$Res> extends _$SentenceEventCopyWithImpl<$Res>
    implements $ResetCopyWith<$Res> {
  _$ResetCopyWithImpl(Reset _value, $Res Function(Reset) _then)
      : super(_value, (v) => _then(v as Reset));

  @override
  Reset get _value => super._value as Reset;
}

/// @nodoc

class _$Reset implements Reset {
  const _$Reset();

  @override
  String toString() {
    return 'SentenceEvent.reset()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Reset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllSentences,
    required TResult Function(Sentence sentence) showNewRandomSentence,
    required TResult Function(Sentence sentence) addToFavourite,
    required TResult Function(String value) newSentenceValueChanged,
    required TResult Function() createNewSentence,
    required TResult Function() reload,
    required TResult Function() clearNewSentenceValue,
    required TResult Function() reset,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllSentences,
    TResult Function(Sentence sentence)? showNewRandomSentence,
    TResult Function(Sentence sentence)? addToFavourite,
    TResult Function(String value)? newSentenceValueChanged,
    TResult Function()? createNewSentence,
    TResult Function()? reload,
    TResult Function()? clearNewSentenceValue,
    TResult Function()? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllSentences value) getAllSentences,
    required TResult Function(ShowNewRandomSentence value)
        showNewRandomSentence,
    required TResult Function(AddToFavourite value) addToFavourite,
    required TResult Function(NewSentenceValueChanged value)
        newSentenceValueChanged,
    required TResult Function(CreateNewSentence value) createNewSentence,
    required TResult Function(Reload value) reload,
    required TResult Function(ClearNewSentenceValue value)
        clearNewSentenceValue,
    required TResult Function(Reset value) reset,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllSentences value)? getAllSentences,
    TResult Function(ShowNewRandomSentence value)? showNewRandomSentence,
    TResult Function(AddToFavourite value)? addToFavourite,
    TResult Function(NewSentenceValueChanged value)? newSentenceValueChanged,
    TResult Function(CreateNewSentence value)? createNewSentence,
    TResult Function(Reload value)? reload,
    TResult Function(ClearNewSentenceValue value)? clearNewSentenceValue,
    TResult Function(Reset value)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class Reset implements SentenceEvent {
  const factory Reset() = _$Reset;
}

/// @nodoc
class _$SentenceStateTearOff {
  const _$SentenceStateTearOff();

  Initial initial(
      {required List<Sentence> sentences,
      required Sentence actualSentence,
      required bool didActualSentenceChange,
      required bool isLoading,
      required String newSentenceValue,
      required bool hasError,
      required bool isRetryButtonClicked,
      required String errorMessage,
      required bool showSnackBar}) {
    return Initial(
      sentences: sentences,
      actualSentence: actualSentence,
      didActualSentenceChange: didActualSentenceChange,
      isLoading: isLoading,
      newSentenceValue: newSentenceValue,
      hasError: hasError,
      isRetryButtonClicked: isRetryButtonClicked,
      errorMessage: errorMessage,
      showSnackBar: showSnackBar,
    );
  }
}

/// @nodoc
const $SentenceState = _$SentenceStateTearOff();

/// @nodoc
mixin _$SentenceState {
  List<Sentence> get sentences => throw _privateConstructorUsedError;
  Sentence get actualSentence => throw _privateConstructorUsedError;
  bool get didActualSentenceChange => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  String get newSentenceValue => throw _privateConstructorUsedError;
  bool get hasError => throw _privateConstructorUsedError;
  bool get isRetryButtonClicked => throw _privateConstructorUsedError;
  String get errorMessage => throw _privateConstructorUsedError;
  bool get showSnackBar => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Sentence> sentences,
            Sentence actualSentence,
            bool didActualSentenceChange,
            bool isLoading,
            String newSentenceValue,
            bool hasError,
            bool isRetryButtonClicked,
            String errorMessage,
            bool showSnackBar)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Sentence> sentences,
            Sentence actualSentence,
            bool didActualSentenceChange,
            bool isLoading,
            String newSentenceValue,
            bool hasError,
            bool isRetryButtonClicked,
            String errorMessage,
            bool showSnackBar)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SentenceStateCopyWith<SentenceState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SentenceStateCopyWith<$Res> {
  factory $SentenceStateCopyWith(
          SentenceState value, $Res Function(SentenceState) then) =
      _$SentenceStateCopyWithImpl<$Res>;
  $Res call(
      {List<Sentence> sentences,
      Sentence actualSentence,
      bool didActualSentenceChange,
      bool isLoading,
      String newSentenceValue,
      bool hasError,
      bool isRetryButtonClicked,
      String errorMessage,
      bool showSnackBar});
}

/// @nodoc
class _$SentenceStateCopyWithImpl<$Res>
    implements $SentenceStateCopyWith<$Res> {
  _$SentenceStateCopyWithImpl(this._value, this._then);

  final SentenceState _value;
  // ignore: unused_field
  final $Res Function(SentenceState) _then;

  @override
  $Res call({
    Object? sentences = freezed,
    Object? actualSentence = freezed,
    Object? didActualSentenceChange = freezed,
    Object? isLoading = freezed,
    Object? newSentenceValue = freezed,
    Object? hasError = freezed,
    Object? isRetryButtonClicked = freezed,
    Object? errorMessage = freezed,
    Object? showSnackBar = freezed,
  }) {
    return _then(_value.copyWith(
      sentences: sentences == freezed
          ? _value.sentences
          : sentences // ignore: cast_nullable_to_non_nullable
              as List<Sentence>,
      actualSentence: actualSentence == freezed
          ? _value.actualSentence
          : actualSentence // ignore: cast_nullable_to_non_nullable
              as Sentence,
      didActualSentenceChange: didActualSentenceChange == freezed
          ? _value.didActualSentenceChange
          : didActualSentenceChange // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      newSentenceValue: newSentenceValue == freezed
          ? _value.newSentenceValue
          : newSentenceValue // ignore: cast_nullable_to_non_nullable
              as String,
      hasError: hasError == freezed
          ? _value.hasError
          : hasError // ignore: cast_nullable_to_non_nullable
              as bool,
      isRetryButtonClicked: isRetryButtonClicked == freezed
          ? _value.isRetryButtonClicked
          : isRetryButtonClicked // ignore: cast_nullable_to_non_nullable
              as bool,
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
      showSnackBar: showSnackBar == freezed
          ? _value.showSnackBar
          : showSnackBar // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class $InitialCopyWith<$Res> implements $SentenceStateCopyWith<$Res> {
  factory $InitialCopyWith(Initial value, $Res Function(Initial) then) =
      _$InitialCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Sentence> sentences,
      Sentence actualSentence,
      bool didActualSentenceChange,
      bool isLoading,
      String newSentenceValue,
      bool hasError,
      bool isRetryButtonClicked,
      String errorMessage,
      bool showSnackBar});
}

/// @nodoc
class _$InitialCopyWithImpl<$Res> extends _$SentenceStateCopyWithImpl<$Res>
    implements $InitialCopyWith<$Res> {
  _$InitialCopyWithImpl(Initial _value, $Res Function(Initial) _then)
      : super(_value, (v) => _then(v as Initial));

  @override
  Initial get _value => super._value as Initial;

  @override
  $Res call({
    Object? sentences = freezed,
    Object? actualSentence = freezed,
    Object? didActualSentenceChange = freezed,
    Object? isLoading = freezed,
    Object? newSentenceValue = freezed,
    Object? hasError = freezed,
    Object? isRetryButtonClicked = freezed,
    Object? errorMessage = freezed,
    Object? showSnackBar = freezed,
  }) {
    return _then(Initial(
      sentences: sentences == freezed
          ? _value.sentences
          : sentences // ignore: cast_nullable_to_non_nullable
              as List<Sentence>,
      actualSentence: actualSentence == freezed
          ? _value.actualSentence
          : actualSentence // ignore: cast_nullable_to_non_nullable
              as Sentence,
      didActualSentenceChange: didActualSentenceChange == freezed
          ? _value.didActualSentenceChange
          : didActualSentenceChange // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      newSentenceValue: newSentenceValue == freezed
          ? _value.newSentenceValue
          : newSentenceValue // ignore: cast_nullable_to_non_nullable
              as String,
      hasError: hasError == freezed
          ? _value.hasError
          : hasError // ignore: cast_nullable_to_non_nullable
              as bool,
      isRetryButtonClicked: isRetryButtonClicked == freezed
          ? _value.isRetryButtonClicked
          : isRetryButtonClicked // ignore: cast_nullable_to_non_nullable
              as bool,
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
      showSnackBar: showSnackBar == freezed
          ? _value.showSnackBar
          : showSnackBar // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial(
      {required this.sentences,
      required this.actualSentence,
      required this.didActualSentenceChange,
      required this.isLoading,
      required this.newSentenceValue,
      required this.hasError,
      required this.isRetryButtonClicked,
      required this.errorMessage,
      required this.showSnackBar});

  @override
  final List<Sentence> sentences;
  @override
  final Sentence actualSentence;
  @override
  final bool didActualSentenceChange;
  @override
  final bool isLoading;
  @override
  final String newSentenceValue;
  @override
  final bool hasError;
  @override
  final bool isRetryButtonClicked;
  @override
  final String errorMessage;
  @override
  final bool showSnackBar;

  @override
  String toString() {
    return 'SentenceState.initial(sentences: $sentences, actualSentence: $actualSentence, didActualSentenceChange: $didActualSentenceChange, isLoading: $isLoading, newSentenceValue: $newSentenceValue, hasError: $hasError, isRetryButtonClicked: $isRetryButtonClicked, errorMessage: $errorMessage, showSnackBar: $showSnackBar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Initial &&
            (identical(other.sentences, sentences) ||
                const DeepCollectionEquality()
                    .equals(other.sentences, sentences)) &&
            (identical(other.actualSentence, actualSentence) ||
                const DeepCollectionEquality()
                    .equals(other.actualSentence, actualSentence)) &&
            (identical(
                    other.didActualSentenceChange, didActualSentenceChange) ||
                const DeepCollectionEquality().equals(
                    other.didActualSentenceChange, didActualSentenceChange)) &&
            (identical(other.isLoading, isLoading) ||
                const DeepCollectionEquality()
                    .equals(other.isLoading, isLoading)) &&
            (identical(other.newSentenceValue, newSentenceValue) ||
                const DeepCollectionEquality()
                    .equals(other.newSentenceValue, newSentenceValue)) &&
            (identical(other.hasError, hasError) ||
                const DeepCollectionEquality()
                    .equals(other.hasError, hasError)) &&
            (identical(other.isRetryButtonClicked, isRetryButtonClicked) ||
                const DeepCollectionEquality().equals(
                    other.isRetryButtonClicked, isRetryButtonClicked)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.showSnackBar, showSnackBar) ||
                const DeepCollectionEquality()
                    .equals(other.showSnackBar, showSnackBar)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sentences) ^
      const DeepCollectionEquality().hash(actualSentence) ^
      const DeepCollectionEquality().hash(didActualSentenceChange) ^
      const DeepCollectionEquality().hash(isLoading) ^
      const DeepCollectionEquality().hash(newSentenceValue) ^
      const DeepCollectionEquality().hash(hasError) ^
      const DeepCollectionEquality().hash(isRetryButtonClicked) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(showSnackBar);

  @JsonKey(ignore: true)
  @override
  $InitialCopyWith<Initial> get copyWith =>
      _$InitialCopyWithImpl<Initial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Sentence> sentences,
            Sentence actualSentence,
            bool didActualSentenceChange,
            bool isLoading,
            String newSentenceValue,
            bool hasError,
            bool isRetryButtonClicked,
            String errorMessage,
            bool showSnackBar)
        initial,
  }) {
    return initial(
        sentences,
        actualSentence,
        didActualSentenceChange,
        isLoading,
        newSentenceValue,
        hasError,
        isRetryButtonClicked,
        errorMessage,
        showSnackBar);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Sentence> sentences,
            Sentence actualSentence,
            bool didActualSentenceChange,
            bool isLoading,
            String newSentenceValue,
            bool hasError,
            bool isRetryButtonClicked,
            String errorMessage,
            bool showSnackBar)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(
          sentences,
          actualSentence,
          didActualSentenceChange,
          isLoading,
          newSentenceValue,
          hasError,
          isRetryButtonClicked,
          errorMessage,
          showSnackBar);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements SentenceState {
  const factory Initial(
      {required List<Sentence> sentences,
      required Sentence actualSentence,
      required bool didActualSentenceChange,
      required bool isLoading,
      required String newSentenceValue,
      required bool hasError,
      required bool isRetryButtonClicked,
      required String errorMessage,
      required bool showSnackBar}) = _$Initial;

  @override
  List<Sentence> get sentences => throw _privateConstructorUsedError;
  @override
  Sentence get actualSentence => throw _privateConstructorUsedError;
  @override
  bool get didActualSentenceChange => throw _privateConstructorUsedError;
  @override
  bool get isLoading => throw _privateConstructorUsedError;
  @override
  String get newSentenceValue => throw _privateConstructorUsedError;
  @override
  bool get hasError => throw _privateConstructorUsedError;
  @override
  bool get isRetryButtonClicked => throw _privateConstructorUsedError;
  @override
  String get errorMessage => throw _privateConstructorUsedError;
  @override
  bool get showSnackBar => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InitialCopyWith<Initial> get copyWith => throw _privateConstructorUsedError;
}
